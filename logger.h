#pragma once

#include <QObject>
#include <QMutex>
#include <QFile>
#include <QTextStream>
#include <QThread>
#include <QDateTime>
#include <QMessageBox>

// -----------------------------------------------------------------------------
// Уровни логирования
// -----------------------------------------------------------------------------
enum class logLevel
{
    Info,     // Информационные сообщения
    Warning,  // Предупреждения, которые могут потребовать внимания
    Error     // Ошибки, которые могут нарушить работу программы
};

// -----------------------------------------------------------------------------
// Logger — потокобезопасный синглтон для логирования в файл
// -----------------------------------------------------------------------------
class Logger : public QObject
{
    Q_OBJECT

public:
    // -------------------------------------------------------------------------
    // Получение единственного экземпляра (Singleton)
    // -------------------------------------------------------------------------
    static Logger& getInstance()
    {
        // Локальная статическая переменная создается один раз при первом вызове.
        // Она гарантирует наличие только одного экземпляра Logger во всем приложении.
        static Logger instance;
        return instance;
    }

    // -------------------------------------------------------------------------
    // Установка минимального уровня логирования
    // Сообщения ниже этого уровня будут игнорироваться.
    // -------------------------------------------------------------------------
    void setMinLevel(logLevel lvl) { minLevel = lvl; }

    // -------------------------------------------------------------------------
    // Публичный метод для логирования
    // Любой поток может вызвать logMessage(), безопасно благодаря сигналам/слотам
    // -------------------------------------------------------------------------
    void logMessage(logLevel lvl, const QString& msg)
    {
        // Проверяем, доступен ли поток и открыт ли файл
        bool enabled = logFile.isOpen() && logThread != nullptr;
        if(!enabled) return; // Если Logger не готов — тихо игнорируем

        // Отправляем сообщение в слот handleLog() через сигнал
        // Qt::QueuedConnection гарантирует, что handleLog выполнится в потоке Logger
        emit logSignal(lvl, msg);
    }

signals:
    // -------------------------------------------------------------------------
    // Сигнал для передачи сообщения в слот handleLog()
    // Используется для безопасного логирования из разных потоков
    // -------------------------------------------------------------------------
    void logSignal(logLevel lvl, const QString& msg);

private slots:
    // -------------------------------------------------------------------------
    // Слот для обработки сообщений
    // Вызывается в потоке Logger при каждом лог-сообщении
    // -------------------------------------------------------------------------
    void handleLog(logLevel lvl, const QString& msg)
    {
        // Игнорируем сообщения ниже минимального уровня
        if(lvl < minLevel) return;

        QString prefix;  // Префикс для уровня логирования

        // Определяем префикс по уровню
        switch(lvl)
        {
        case logLevel::Info: prefix = "[INFO]"; break;
        case logLevel::Warning: prefix = "[WARNING]"; break;
        case logLevel::Error: prefix = "[ERROR]"; break;
        }

        // Потокобезопасная запись в файл:
        // QMutexLocker блокирует мьютекс при создании и автоматически разблокирует
        // при выходе из области видимости (RAII)
        QMutexLocker<QMutex> lock(&mtx);

        // Формируем запись: дата/время + префикс + сообщение
        out << QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss")
            << ' ' << prefix << ' ' << msg << '\n';

        // flush() гарантирует немедленную запись на диск
        out.flush();
    }

private:
    // -------------------------------------------------------------------------
    // Приватный конструктор
    // -------------------------------------------------------------------------
    Logger(QObject* parent = nullptr)
        : QObject(parent)
        , out(&logFile) // QTextStream пишет в logFile
    {
        // Указываем имя файла логирования
        logFile.setFileName("log.txt");

        // Пытаемся открыть файл для дозаписи
        if(!logFile.open(QIODevice::Append | QIODevice::Text))
        {
            // Если файл не открылся — показываем предупреждение
            // Программа продолжает работу без логирования
            QMessageBox::warning(nullptr, "Logger error",
                                 QString("Не удалось открыть лог-файл: Приложение продолжит работу без логирования."));
            logThread = nullptr;
            return; // Конструктор завершает и Logger остается в "неактивном" состоянии
        }

        // Создаем поток для логирования
        logThread = new QThread();

        // Перемещаем объект Logger в отдельный поток
        this->moveToThread(logThread);

        // Соединяем сигнал с обработкой слотом в режиме очереди сообщений
        connect(this, &Logger::logSignal, this, &Logger::handleLog, Qt::QueuedConnection);

        // Запускаем поток
        logThread->start();
        logMessage(logLevel::Info, "Новая сессия!");
    }

    // -------------------------------------------------------------------------
    // Деструктор
    // -------------------------------------------------------------------------
    ~Logger()
    {
        // Завершаем поток корректно, если он был создан
        if(logThread)
        {
            logThread->quit();  // Просим поток завершиться
            logThread->wait();  // Ждем завершения всех операций
            delete logThread;   // Удаляем объект потока
        }

        // Закрываем файл логирования, если он открыт
        if(logFile.isOpen())
        {
            logFile.close();
        }
    }

    // -------------------------------------------------------------------------
    // Запрет копирования и перемещения
    // -------------------------------------------------------------------------
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
    Logger(Logger&&) = delete;
    Logger& operator=(Logger&&) = delete;

    QFile logFile;        // Файл для логирования
    QTextStream out;      // Поток для записи текста в файл
    QMutex mtx;           // Мьютекс для потокобезопасной записи
    logLevel minLevel = logLevel::Info; // Минимальный уровень логирования
    QThread* logThread;   // Поток, в котором работает Logger
};
