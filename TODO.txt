1. Плагины / QPluginLoader

 - Убедиться, что перед повторной загрузкой всех плагинов полностью очищены все внутренние
 векторы (pluginsLoad, pluginsInterface, filePaths) и обнулены все указатели на instance, включая gameInterface.

 - Вызывать instance()->disconnect() перед unload(), чтобы все сигналы/слоты отключались.

 - Добавить проверку таймеров или дочерних объектов плагина — они могут блокировать unload().

 - Проверить, что DeleteAll<QPluginLoader> корректно удаляет объекты после успешного unload.

2. Удаление плагинов

 - Сделать так, чтобы после deletePlug() новые .deleted.* файлы очищались корректно, а не только старые.

 - Проверить логику переименования файла в .deleted.* — убедиться, что новый tombstone не блокирует следующую загрузку плагина.

 - Добавить небольшую задержку или событийному циклу дать время ОС освободить DLL перед удалением.

3. Обновление плагинов (updatePlug)

 - Исключить «дубли» на нижнем уровне (в internal vectors) при обновлении.

 - Перед вызовом loadPlugin() очищать все старые указатели и unload-ить DLL.

 - Проверить, что mw->namePlugin синхронизирован с pluginsInterface и pluginsLoad — порядок и количество элементов должны совпадать.

4. GUI и внутренние структуры

 - Проверить, что после удаления или обновления плагинов GUI и internal vectors синхронизированы.

 - Очистка элементов QListWidget должна удалять соответствующие элементы в двух связанных списках, если есть.

 - Проверить использование QTimer::singleShot при удалении/очистке — чтобы мусор реально удалялся до следующей загрузки.

5. NVDA / Talk / Озвучка

 - Проверить, что gameInterface не держит ссылку на объект плагина при unload.

 - Синхронизация озвучки: таймеры и singleShot не должны конфликтовать с удалением или обновлением плагинов.
